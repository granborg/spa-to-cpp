use flate2::Compression;
use flate2::write::GzEncoder;
use std::io::Write;

const OUT_WEBUI_H: &str = r#"/* THIS FILE WAS GENERATED BY A SCRIPT! DO NOT EDIT! */
#ifndef WEB_UI
#define WEB_UI
#include <cstdint>
#include <vector>

class FileManifest {
	public:
		std::string route;
		uint8_t* bytes;
		size_t bytes_len;
};

#ifdef __cplusplus
extern "C" {
#endif

void getFileManifests(std::vector<FileManifest*> &file_manifests);

#ifdef __cplusplus
}
#endif

#endif
"#;

fn find_files(dist_folder: String) -> Vec<String> {
    let mut files: Vec<String> = Vec::new();

    for entry in walkdir::WalkDir::new(dist_folder) {
        if let Ok(entry) = entry {
            if !entry.file_type().is_dir() {
                files.push(entry.path().to_string_lossy().to_string());
            }
        }
    }

    files
}

fn compress(uncompressed_data: &Vec<u8>) -> Vec<u8> {
    let mut encoder: GzEncoder<Vec<u8>> = GzEncoder::new(Vec::new(), Compression::best());
    encoder.write_all(&uncompressed_data).unwrap();

    encoder.finish().unwrap()
}


fn format_bytes(data: &Vec<u8>) -> String {
    let hex_bytes: Vec<String> = data.iter().map(|b| format!("0x{:02X}", b)).collect();
    let hex_bytes_comma_sep = hex_bytes.join(", ");
    let mut hex_bytes_formatted = String::new();

    let mut bytes_seen = 0;
    let bytes_per_line = 12;
    for b in hex_bytes_comma_sep.split_whitespace() {
        if bytes_seen == 0 {
            hex_bytes_formatted.push_str("\t");
        }

        if bytes_seen == bytes_per_line - 1 {
            bytes_seen = 0;
            hex_bytes_formatted.push_str(&format!("{}\n", b));
            continue;
        }

        hex_bytes_formatted.push_str(&format!("{:6}", b));
        bytes_seen += 1;
    }

    format!("{{\n{}\n}};\n", hex_bytes_formatted)
}

fn generate_cpp_file_contents(files: Vec<String>, dist_folder: String) -> String {
    let mut cpp_file_contents: String = String::new();

    cpp_file_contents += "/* THIS FILE WAS GENERATED BY A SCRIPT! DO NOT EDIT! */\n";
    cpp_file_contents += "#include <vector>\n";
    cpp_file_contents += "#include <string>\n";
    cpp_file_contents += "#include \"webui.h\"\n";

    let mut uncompressed_data_lengths: Vec<usize> = Vec::new();
    let mut compressed_data_lengths: Vec<usize> = Vec::new();

    for i in 0..files.len() {
        let file = &files[i];
        let uncompressed_data: Vec<u8> = std::fs::read(file).unwrap();
        uncompressed_data_lengths.push(uncompressed_data.len());

        let compressed_data: Vec<u8> = compress(&uncompressed_data);
        compressed_data_lengths.push(compressed_data.len());

        let bytes_name: String = format!("b{}", i);
        cpp_file_contents += &format!("const uint8_t {}[{}] =\n", bytes_name, compressed_data.len());

        let formatted_bytes: String = format_bytes(&compressed_data);
        cpp_file_contents += &formatted_bytes;
    }

    cpp_file_contents += "void getFileManifests(std::vector<FileManifest*>& file_manifests) {\n";

    for i in 0..files.len() {
        let file = &files[i];
        let route: String = file.replace(dist_folder.as_str(), "");
        let manifest_name: String = format!("f{}", i);
        let bytes_name: String = format!("b{}", i);

        cpp_file_contents += &format!("FileManifest *{} = new FileManifest();\n", manifest_name);
        cpp_file_contents += &format!("{}->bytes = (uint8_t *)&{};\n", manifest_name, bytes_name);
        cpp_file_contents += &format!("{}->bytes_len = {};\n", manifest_name, compressed_data_lengths[i]);
        cpp_file_contents += &format!("{}->route = \"{}\";\n", manifest_name, route);
        cpp_file_contents += &format!("file_manifests.push_back({});\n", manifest_name);

        println!("Compressed {}:", route);
        println!("\tRaw size:          {:.2}kb", uncompressed_data_lengths[i] as f64 / 1000.0);
        println!("\tCompressed size:   {:.2}kb", compressed_data_lengths[i] as f64/ 1000.0);
        println!("\tCompression ratio: {:.2}%", (1.0 - (compressed_data_lengths[i] as f64 / uncompressed_data_lengths[i] as f64)) * 100.0);
    }

    cpp_file_contents += "}\n";

    cpp_file_contents
}

fn main() {
    let dist_folder = std::env::args().nth(1).expect("No dist folder provided.");
    let mut out_folder = std::env::args().nth(2).expect("No output folder provided.");

    if !out_folder.ends_with("/") {
        out_folder += "/";
    }

    println!("Dist folder: {}", dist_folder);

    let cpp_path: String = format!("{}webui.cpp", out_folder);
    let h_path: String = format!("{}webui.h", out_folder);

    println!("Output files: {} and {}", cpp_path, h_path);

    let files = find_files(dist_folder.clone());
    let cpp_file_contents: String = generate_cpp_file_contents(files, dist_folder.clone());

    std::fs::write(cpp_path, cpp_file_contents).expect("Could not write the .cpp file!");
    std::fs::write(h_path, OUT_WEBUI_H).expect("Could not write the .h file!");
}
